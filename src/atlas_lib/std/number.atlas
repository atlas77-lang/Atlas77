package std::number;

public concept Add: impl operator::(+) {
    /// No need to specify a function, you already forced the implementation of the operator
}
/// How can I differentiate between the unary and binary operators?
/// I can't use the same concept for both, because the unary operator doesn't have two operands.
public concept Sub: impl operator::(-) {}
public concept Mul: impl operator::(*) {}
public concept Div: impl operator::(/) {}
public concept Mod: impl operator::(%) {}
public concept Eq: impl operator::(==), operator::(!=) {}
public concept Ord: impl operator::(<), operator::(<=), operator::(>), operator::(>=) {}
public concept AddAssign: impl operator::(+=) {}
public concept SubAssign: impl operator::(-=) {}
public concept MulAssign: impl operator::(*=) {}
public concept DivAssign: impl operator::(/=) {}
public concept ModAssign: impl operator::(%=) {}
public concept Inc: impl operator::(++) {}
public concept Dec: impl operator::(--) {}

public concept From<T> {
    // "Self" can only be used in a concept
    func from(value: T) -> Self;
}

public concept Copy: impl operator::(<-) {}

public concept Into<T> {
    func into(self) -> T;
}

/// Structs are value types, and are passed by value.
public struct Int64: 
    impl Add, Sub, Mul, Div, Mod, Eq, NEq, Lt, LtEq, Gt, GtEq, 
    AddAssign, SubAssign, MulAssign, DivAssign, ModAssign, Inc, Dec,
    Copy, From<int64>, From<uint64>, Into<int64>
{
    value: int64;
    const MAX: int64 = 9223372036854775807;
    const MIN: int64 = -9223372036854775808;
    /// Marking the constructor as `const` makes it usable for constant expressions.
    const Int64(value: int64) {
        self.value = value;
    }
    ~Int64() {
        //delete self.value;
    }
    func to_str(self) -> str {
        return self.value as str;
    }
    func zeroed() -> Int64 {
        return new Int64(0);
    }
    operator +(self, other: Int64) -> Int64 {
        return new Int64(self.value + other.value);
    }
    operator -(self, other: Int64) -> Int64 {
        return new Int64(self.value - other.value);
    }
    operator -(self) -> Int64 {
        return new Int64(-self.value);
    }
    operator *(self, other: Int64) -> Int64 {
        return new Int64(self.value * other.value);
    }
    operator /(self, other: Int64) -> Int64 {
        return new Int64(self.value / other.value);
    }
    operator %(self, other: Int64) -> Int64 {
        return new Int64(self.value % other.value);
    }
    operator ==(self, other: Int64) -> bool {
        return self.value == other.value;
    }
    operator !=(self, other: Int64) -> bool {
        return self.value != other.value;
    }
    operator <(self, other: Int64) -> bool {
        return self.value < other.value;
    }
    operator <=(self, other: Int64) -> bool {
        return self.value <= other.value;
    }
    operator >(self, other: Int64) -> bool {
        return self.value > other.value;
    }
    operator >=(self, other: Int64) -> bool {
        return self.value >= other.value;
    }
    operator +=(self, other: Int64) -> Int64 {
        self.value += other.value;
        return self;
    }
    operator -=(self, other: Int64) -> Int64 {
        self.value -= other.value;
        return self;
    }
    operator *=(self, other: Int64) -> Int64 {
        self.value *= other.value;
        return self;
    }
    operator /=(self, other: Int64) -> Int64 {
        self.value /= other.value;
        return self;
    }
    operator %=(self, other: Int64) -> Int64 {
        self.value %= other.value;
        return self;
    }
    operator ++(self) -> Int64 {
        self.value += 1;
        return self;
    }
    operator --(self) -> Int64 {
        self.value -= 1;
        return self;
    }
    /// The copy operator is used to copy the value of a variable to another variable.
    operator <-(self) -> Int64 {
        return new Int64(self.value);
    }
    #[override(From<int64>::from)]
    /// Functions marked as `override` have their name mangled with the concept name.
    /// from(int64) -> Int64 becomes from_int64_Int64
    func from(value: int64) -> Int64 {
        return new Int64(value);
    }
    #[override(From<uint64>::from)]
    func from(value: uint64) -> Int64 {
        return new Int64(value as int64);
    }
    #[override(From<float64>::from)]
    func from(value: float64) -> Int64 {
        return new Int64(value as int64);
    }
    #[override(Into<int64>::into)]
    func into(self) -> int64 {
        return self.value;
    }
}