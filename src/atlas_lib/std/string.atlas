package std::string;

import "std/vector"

// Miscellaneous functions for raw strings
public extern str_len(s: str) -> uint64
public extern trim(s: str) -> str
public extern to_upper(s: str) -> str
public extern to_lower(s: str) -> str
public extern split(s: str, sep: str) -> [str]
public extern str_cmp(s1: str, s2: str) -> int64

public concept ToString {
    func to_string(self) -> String;
}

public concept ToStr {
    func to_str(self) -> str;
}

public class String : impl Indexable<char> {
    private:
        // As there is no uint8 type, we use char
        // char is a 32-bit unicode character
        s: Vec<char>;
    // This mark every method under it as public
    public:
        // Only 1 constructor is allowed in the language `ClassName(args)`
        // Only 1 destructor is allowed in the language `~ClassName()`
        // This is called with the `new` keyword
        String(s: str) {
            let string = s as [char];
            let vector = new Vec<char>(string);
            self.s = vector;
            self.len = vector.len();
        }
        ~String() {
            // This is called explicitly with the `delete` keyword
            // If you know that you have cyclic references, 
            //  you can call it explicitly and break the cycle
            // This is automatically called when the object goes out of scope
        }
        operator [](self, i: uint64) -> char {
            return self.s[i];
        }
        operator []=(self, i: uint64, v: char) {
            self.s[i] = v;
        }
        operator ==(self, other: String) -> bool {
            return str_cmp(self.s as str, other.s as str) == 0;
        }
        operator !=(self, other: String) -> bool {
            return str_cmp(self.s as str, other.s as str) != 0;
        }        
        func from(s: str) -> String {
            return new String(s, str_len(s));
        }
        #[override(Indexable<char>::len)]
        func len() -> uint64 {
            return self.s.len();
        }
        #[override(Indexable<char>::get)]
        func get(i: uint64) -> char {
            return self[i];
        }
        #[override(Indexable<char>::set)]
        func set(i: uint64, v: char) {
            self[i] = v;
        }
        func push(self, c: char) {
            self.s.push(c);
            self.len = self.len + 1;
        }
        func push_str(self, s: str) {
            let i = 0;
            while i < str_len(s) {
                self.push(s[i]);
                i = i + 1;
            }
        }
        // This is a static method that is called with the `::` operator
        // In atlas77 it is called a `factory` method
        // It is used to create an object of the class with different parameters than the constructor
        func with_capacity(capacity: uint64) -> String {
            return new String("", capacity);
        }
        func empty() -> String {
            return new String("");
        }
        func is_empty(self) -> bool {
            return self.len == 0;
        }
        // This is a "standard" method that is called with the `.` operator
        func len(self) -> uint64 {
            return self.len;
        }
}
