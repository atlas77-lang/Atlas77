package std::vector;

// Import the base functions for [T]
import "std/list"
//    This import statement add those functions:
//    public extern len<T>(l: [T]) -> int64
//    public extern slice<T>(l: [T], start: int64, end: int64) -> [T]

// This can be used as a Type to enforce the implementation of the Indexable<T> concept
// You can also use it as a Type to store a reference to an object that implements the Indexable<T> concept
public concept Indexable<T, Idx>
where T: impl Copy {
    func len() -> uint64;
    func get(i: Idx) -> T;
    func set(i: Idx, v: T);
}
public concept Copy : operator::(<-) {}

public class Vec<T> : impl Indexable<T, uint64> {
    private:
        data: [T];
        cap: uint64;
    public:
        len: uint64;
    public:
        // Constructor
        // There is only one constructor in atlas77
        // You don't need to specify the return type of the constructor nor `self`
        // It is called with the `new` keyword
        Vec(data: [T]) {
            self.data = data;
            self.len = len(data);
            self.cap = len(data);
        }
        // Destructor
        // There is only one destructor in atlas77
        // It is called with the `delete` keyword
        // It is also called automatically with the reference counting system
        // It can be used if you want a specific behavior when the object is deleted
        ~Vec() {
            delete self.data;
        }
        // Need to find a good syntax for operator overloading
        operator [](self, i: uint64) -> T {
            return self.data[i];
        }
        operator []=(self, i: uint64, v: T) {
            self.data[i] = v;
        }
        //
        func with_capacity(cap: uint64) -> Vec<T> {
            let list = new [T; cap];
            let vec = new Vec(list);
            vec.len = 0;
            return vec;
        }
        // This specify that the function is an override of the Indexable<T> concept
        // This is not mandatory but it is a good practice
        //
        // It can be mandatory if you implement multiple concepts with the same function name
        // e.g. From<[T]> or From<T> will have the same function name `from`
        // So to let the compiler properly differentiate them, you need to specify the concept
        #[override(Indexable<T, uint64>::len)]
        func len(self) -> uint64 {
            return self.len;
        }
        #[override(Indexable<T, uint64>::get)]
        func get(self, i: uint64) -> T {
            // We can use `operator []`
            return self[i];
        }
        #[override(Indexable<T, uint64>::set)]
        func set(i: uint64, v: T) {
            // We can use `operator []=`
            self[i] = v;
        }
        func push(self, v: T) {
            if self.len == self.cap {
                // Allocate a new array with double the capacity
                let new_data = new [T; self.cap * 2];
                // Copy the old data to the new array
                new_data <- self.data;
                self.data = new_data;
                self.cap *= 2;
            } else {
                self.data[self.len] = v;
                self.len += 1;
            }
        }
        // This should return T directly because what if self.len == 0?
        func pop(self) -> T {
            self.len -= 1;
            return self.data[self.len];
        }
        func insert(self, idx: uint64) {
            if self.len == self.cap {
                // Allocate a new array with double the capacity
                let new_data = new [T; self.cap * 2];
                // Copy the old data to the new array
                new_data <- self.data;
                self.data = new_data;
                self.cap *= 2;
            }
            // Shift the elements to the right
            let i = 0;
            while i < self.len - idx {
                self.data[self.len - i] = self.data[self.len - i - 1];
                i += 1;
            }

            self.len += 1;
        }
}
